import { generateFvttId } from "../utils";

const { api } = foundry.applications;

export class RtRActor extends Actor {
    /** @override */
    prepareData() {
        // Prepare data for the actor. Calling the super version of this executes
        // the following, in order: data reset (to clear active effects),
        // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
        // prepareDerivedData().
        super.prepareData();
    }

    /** @override */
    prepareBaseData() {
        // Data modifications in this step occur before processing embedded
        // documents or derived data.
    }

    /**
     * @override
     * Augment the actor source data with additional dynamic data that isn't
     * handled by the actor's DataModel. Data calculated in this step should be
     * available both inside and outside of character sheets (such as if an actor
     * is queried and has a roll executed directly from it).
     */
    prepareDerivedData() {
        const actorData = this;
        const flags = actorData.flags.reclaimtherealm || {};

        this.system
    }

    /**
     *
     * @override
     * Augment the actor's default getRollData() method by appending the data object
     * generated by the its DataModel's getRollData(), or null. This polymorphic
     * approach is useful when you have actors & items that share a parent Document,
     * but have slightly different data preparation needs.
     */
    getRollData() {
        return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
    }

    /* -------------------------------------------- */
    /*  Dice Rolls                                  */
    /* -------------------------------------------- */

    d20Test(options: ActorRollOptions) {
        let die = 'd20';
        if (options.advantage && !options.disadvantage) {
            die = '2d20kh';
        } if (options.disadvantage && !options.advantage) {
            die = '2d20kl';
        }

        let d20TestBonuses = '';
        if (this.getRollData().d20Test !== 0) {
            d20TestBonuses = ' +@d20Test'
        }
        options.extraDice = options.extraDice ? options.extraDice : '';

        if (this._hasStatusEffect('DISTRACTED')) {
            d20TestBonuses = d20TestBonuses + ' -2';
        }

        let formula = `${die}${options.extraDice}${d20TestBonuses}${options.bonus}`;
        return this.roll(formula, options);
    }

    meleeMartialAttack(options: ActorRollOptions) {
        options.type = 'MELEE MARTIAL ATTACK';
        options.bonus = options.bonus ? options.bonus + ' +@meleeMartialAttack' : ' +@meleeMartialAttack';
        if (this._hasStatusEffect('PRONE')) {
            options.disadvantage = true;
        }
        return this._attackTest(options);
    }

    rangedMartialAttack(options: ActorRollOptions) {
        options.type = 'RANGED MARTIAL ATTACK';
        options.bonus = options.bonus ? options.bonus + ' +@rangedMartialAttack' : ' +@rangedMartialAttack';
        return this._attackTest(options);
    }

    meleeSpellAttack(options: ActorRollOptions) {
        options.type = 'MELEE SPELL ATTACK';
        options.bonus = options.bonus ? options.bonus + ' +@meleeSpellAttack' : ' +@meleeSpellAttack';
        if (this._hasStatusEffect('PRONE')) {
            options.disadvantage = true;
        }
        return this._attackTest(options);
    }

    rangedSpellAttack(options: ActorRollOptions) {
        options.type = 'RANGED SPELL ATTACK';
        options.bonus = options.bonus ? options.bonus + ' +@rangedSpellAttack' : ' +@rangedSpellAttack';
        return this._attackTest(options);
    }

    martialTest(options: ActorRollOptions) {
        if (this._hasStatusEffect('FRIGHTENED I')) {
            options.disadvantage = true;
        }
        if (this._hasStatusEffect('CURSED I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' -d4' : ' -d4';
        }
        if (this._hasStatusEffect('BLESS I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' +d4' : ' +d4';
        }
        const attributeTestData = this._getAttributeRollBonus(options.attribute);
        options.type = attributeTestData.rollType + ' MARTIAL TEST';
        options.bonus = options.bonus ? options.bonus + attributeTestData.rollData : attributeTestData.rollData;
        options.bonus = options.bonus ? options.bonus + ' +@martialTest' : ' +@martialTest';

        return this.d20Test(options);
    }

    spellTest(options: ActorRollOptions) {
        if (this._hasStatusEffect('FRIGHTENED I')) {
            options.disadvantage = true;
        }
        if (this._hasStatusEffect('CURSED I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' -d4' : ' -d4';
        }
        if (this._hasStatusEffect('BLESS I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' +d4' : ' +d4';
        }
        const attributeTestData = this._getAttributeRollBonus(options.attribute);
        options.type = attributeTestData.rollType + ' SPELL TEST';
        options.bonus = options.bonus ? options.bonus + attributeTestData.rollData : attributeTestData.rollData;
        options.bonus = options.bonus ? options.bonus + ' +@spellTest' : ' +@spellTest';

        return this.d20Test(options);
    }

    attributeTest(options: ActorRollOptions) {
        let attributeTestData = this._getAttributeRollBonus(options.attribute);
        options.bonus = options.bonus ? options.bonus + attributeTestData.rollData : attributeTestData.rollData;

        if (!options.type) {
            options.type = attributeTestData.rollType + ' ATTRIBUTE TEST';
        } else {
            options.type = attributeTestData.rollType + ' ' + options.type;
        }

        if (this._hasStatusEffect('INTOXICATED') && (options.attribute === 'agi' || options.attribute === 'per')) {
            options.bonus = options.bonus + ' -5';
        }
        if (options.attribute === 'per' && this._hasStatusEffect('DISTRACTED')) {
            options.disadvantage = true;
        }
        if (options.attribute === 'agi' && this._hasStatusEffect('HASTE I')) {
            options.advantage = true;
        }
        if (this._hasStatusEffect('FOCUSED') && (options.attribute === 'int' || options.attribute === 'per')) {
            options.advantage = true;
        }

        return this.d20Test(options);
    }

    skillTest(options: ActorRollOptions) {
        let skillTestData = this._getSkillRollBonus(options.skill);
        options.bonus = options.bonus ? options.bonus + skillTestData.rollData : skillTestData.rollData;
        options.type = skillTestData.rollType + ' SKILL TEST';
        return this.attributeTest(options);
    }

    saveTest(options: ActorRollOptions) {
        let saveRollData = this._getSaveRollBonus(options.save);
        options.bonus = options.bonus ? options.bonus + saveRollData.rollData : saveRollData.rollData;
        options.type = saveRollData.rollType;

        if (this._hasStatusEffect('VULNURABLE I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' -d4' : ' -d4';
        }
        if (this._hasStatusEffect('PROTECTION I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' +d4' : ' +d4';
        }

        return this.d20Test(options);
    }

    // TODO: use enums
    damageRoll(method: string, halfDamage: boolean, options: ActorRollOptions, formula: string, dmgType: string) {
        if (this._hasStatusEffect('WEAKENED I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' -d6' : ' -d6';
        }
        let damage;
        switch (method) {
            case 'lightMartialDamage':
                damage = '@lightMartialDamage';
                break;
            case 'mediumMartialDamage':
                damage = '@mediumMartialDamage';
                break;
            case 'heavyMartialDamage':
                damage = '@heavyMartialDamage';
                break;
            case 'custom':
                damage = formula;
                break;
        }
        let damageFormula;
        if (halfDamage) {
            damageFormula = `floor((${damage}${options.extraDice ?? ''}${options.bonus ?? ''}) / 2)[${dmgType}]`;
        } else {
            damageFormula = `${damage}${options.extraDice ?? ''}${options.bonus ?? ''}[${dmgType}]`;
        }
        return this.roll(damageFormula, options);
    }

    roll(formula: string, options: ActorRollOptions) {
        let label = options.type;
        if (options.advantage && !options.disadvantage) {
            label = '<span style="color:green">ADVANTAGE ' + options.type + '</span>';
        } if (options.disadvantage && !options.advantage) {
            label = '<span style="color:red">DISADVANTAGE ' + options.type + '</span>';
        }
        let roll = new Roll(formula, this.getRollData());
        return roll.toMessage({
            speaker: ChatMessage.getSpeaker({ actor: this }),
            flavor: label
        }, {
            rollMode: game.settings?.get('core', 'rollMode')
        });
    }

    _attackTest(options: ActorRollOptions) {
        if (this._hasStatusEffect('FRIGHTENED I')) {
            options.disadvantage = true;
        }
        if (this._hasStatusEffect('CURSED I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' -d4' : ' -d4';
        }
        if (this._hasStatusEffect('BLESS I')) {
            options.extraDice = options.extraDice ? options.extraDice + ' +d4' : ' +d4';
        }

        return this.d20Test(options);
    }


    /* -------------------------------------------- */
    /*  Ability Functions                           */
    /* -------------------------------------------- */

    // TODO use proper object
    async payAbilityUsageCosts(usageCost: unknown) {
        const updatePayload = {};
        const warningMessages = [];
        if (usageCost.arcanaCost > 0) {
            if (usageCost.arcanaCost > this.system.arcana.value) {
                warningMessages.push(`Not enough arcana to use ability Required: ${usageCost.arcanaCost}, Available: ${this.system.arcana.value}`);
            }
            const newArcana = Math.max(0, this.system.arcana.value - usageCost.arcanaCost);
            updatePayload['system.arcana.value'] = newArcana;
        }
        if (usageCost.staminaCost > 0) {
            if (usageCost.staminaCost > this.system.stamina.value) {
                warningMessages.push(`Not enough stamina to use ability Required: ${usageCost.staminaCost}, Available: ${this.system.stamina.value}`);
            }
            const newStamina = Math.max(0, this.system.stamina.value - usageCost.staminaCost);
            updatePayload['system.stamina.value'] = newStamina;
        }

        if (warningMessages.length > 0) {
            const confirm = await api.DialogV2.prompt({
                content: warningMessages.join('<br>'),
                rejectClose: false,
                modal: true,
                window: { title: "Insufficent Resources for Ability", icon: "fa-solid fa-triangle-exclamation" },
                ok: { label: 'Use Ability anyways' }
            });
            if (!confirm) {
                return false;
            }
        }
        this.update(updatePayload);
        return true;
    }

    castSpell(spellDifficulty: number, spellName: string) {
        let roll = new Roll('2d6+@spellCastBonus', this.getRollData());

        return roll.toMessage({
            speaker: this,
            flavor: `Casting Spell ${spellName}`,
        }, {
            rollMode: game.settings?.get('core', 'rollMode'),
        }).then(result => {
            if (!result) return;

            let text = '';
            let doubleOnes = (result.rolls[0].terms[0].results[0].result === 1) && (result.rolls[0].terms[0].results[1].result === 1);
            let success = true;
            if ((result.rolls[0].total >= spellDifficulty) && !doubleOnes) {
                text = `<span style="color:green">Spell ${spellName} was successfuly cast</span>`;
            } else if (result.rolls[0].total >= (spellDifficulty - 5)) {
                text = `<span style="color:yellow">Spell ${spellName} was cast with mishap</span>`;
            } else {
                text = `<span style="color:red">Spell ${spellName} Cast was unsuccessful and mishap occurs</span>`;
                success = false;
            }

            ChatMessage.create({
                speaker: this,
                content: text,
                style: CONST.CHAT_MESSAGE_STYLES.OOC
            });
            return success;
        });
    }

    // TODO use enums in response
    determineAttackHist(attackResult: number, unmodifiedResult: number, attackerName: string) {
        if (this.type === 'npc') {
            { [] }
            if (unmodifiedResult === 1) {
                return Promise.resolve('onFailure');
            } else if (unmodifiedResult === 20) {
                return Promise.resolve('onHit');
            } else if (attackResult >= (10 + this.system.defenses.dodge)) {
                return Promise.resolve('onHit');
            } else {
                return Promise.resolve('onPartialHit');
            }
        } else {
            const characterUser = game.users.filter(u => u.active).find(u => u?.character?.id === this.id);
            return api.DialogV2.query(characterUser ?? game.users.activeGM, 'prompt', {
                content: `${attackerName} attacked you (${attackResult}). Roll a Dodge?`,
                rejectClose: false,
                modal: true,
                window: { title: 'Incoming Attack!' },
                ok: { label: 'Roll to Dodge' }
            }).then(confirm => {
                if (!confirm) {
                    return Promise.resolve('onFailure');
                }
                return this.saveTest({ save: 'dodge' }).then(roll => {
                    const unmodifiedResult = roll?.rolls[0]?.terms[0]?.results[0]?.result;
                    const rollTotal = roll.rolls[0].total;
                    if (unmodifiedResult === 1) {
                        return Promise.resolve('onHit');
                    } else if (unmodifiedResult === 20) {
                        return Promise.resolve('onFailure');
                    } else if (attackResult >= rollTotal) {
                        return Promise.resolve('onHit');
                    } else {
                        return Promise.resolve('onPartialHit');
                    }
                });
            });
        }
    }
s
    // TODO - use enums
    determineDefensiveTestResult(defense: string, attackResult: number, attackerName: string) {
        if (this.type === 'npc') {
            let defenseThreshold = 99;
            if (defense === 'STABILITY') {
                defenseThreshold = (10 + this.system.defenses.stability);
            } else if (defense === 'DODGE') {
                defenseThreshold = (10 + this.system.defenses.dodge);
            } else if (defense === 'TOUGHNESS') {
                defenseThreshold = (10 + this.system.defenses.toughness);
            } else if (defense === 'WILLPOWER') {
                defenseThreshold = (10 + this.system.defenses.willpower);
            }S
            if (attackResult > defenseThreshold) {
                return Promise.resolve('onSuccess');
            } else {
                return Promise.resolve('onFailure');
            }
        } else {
            const characterUser = game.users?.find(u => u?.character?.id === this.id);
            return api.DialogV2.query(characterUser ?? game.users?.activeGM, 'prompt', {
                content: `${attackerName} targets you (${attackResult}). Make a ${defense} Save?`,
                rejectClose: false,
                modal: true,
                window: { title: 'Incoming Attack!' },
                ok: { label: `Roll for ${defense} Save` }
            }).then(confirm => {
                if (!confirm) {
                    return Promise.resolve('onFailure');
                }
                return this.saveTest({ save: defense.toLowerCase() }).then(roll => {
                    const rollTotal = roll.rolls[0].total;
                    if (attackResult >= rollTotal) {
                        return Promise.resolve('onSuccess');
                    } else {
                        return Promise.resolve('onFailure');
                    }
                });
            });
        }
    }

    /* -------------------------------------------- */
    /*  Interactions with other Actors              */
    /* -------------------------------------------- */

    // TODO use enum
    applyDamage(amount: number, type: string) {
        let remainingAmount = amount;
        if (this.system.tempHp > 0) {
            remainingAmount = amount - Math.min(this.system.tempHp, amount);
            let newTempHp = Math.max(0, this.system.tempHp - amount);
            this.update({ "system.tempHp": newTempHp });
        }
        const reducedTempHP = amount - remainingAmount;
        const resistanceAmount = this._hasResistance(type);
        remainingAmount = Math.max(0, remainingAmount - resistanceAmount);
        let newHp = Math.max(0, this.system.hp.value - remainingAmount);
        this.update({ "system.hp.value": newHp });

        let additionalText = '';
        if (reducedTempHP > 0) {
            additionalText += `<span>TempHP reduced by ${reducedTempHP}</span>`;
        } if (resistanceAmount > 0) {
            additionalText += `<span>Damaged reduced by ${resistanceAmount} from resistances</span>`;
        }

        ChatMessage.create({
            speaker: ChatMessage.getSpeaker({ actor: this }),
            content: `<div class="flexcol">
        <strong>${this.name} recieved ${remainingAmount} ${type} damage.</strong>
        ${additionalText}
        <div>`,
            style: CONST.CHAT_MESSAGE_STYLES.OOC
        });
    }

    heal(amount: number, healTHP: boolean) {
        let chatMessage = '';
        if (healTHP) {
            let newTHP = Math.max(this.system.tempHp, amount);
            if (newTHP > this.system.tempHp) {
                chatMessage = `${this.name} gains ${amount} THP. (${this.system.tempHp} -> ${newTHP})`;
                this.update({ "system.tempHp": newTHP });
            } else {
                chatMessage = `${this.name} is already at (${this.system.tempHp} THP.`;
            }
        } else {
            let newHp = Math.min(this.system.hp.max, this.system.hp.value + amount);
            chatMessage = `${this.name} heals ${amount} HP. (${this.system.hp.value} -> ${newHp})`;
            this.update({ "system.hp.value": newHp });
        }
        ChatMessage.create({
            speaker: ChatMessage.getSpeaker({ actor: this }),
            content: chatMessage,
            style: CONST.CHAT_MESSAGE_STYLES.OOC
        });
    }

    // TODO, enum
    async toggleStatusEffect(statusEffectId: string) {
        const existing = this.effects.get(generateFvttId(`RTR${statusEffectId}`));
        if (existing) return existing.delete();
        const effect = await ActiveEffect.implementation.fromStatusEffect(statusEffectId);
        return ActiveEffect.implementation.create(effect, { parent: this, keepId: true });
    }

    // TODO, enum
    async applyStatusEffect(statusEffectId: string, roundDuration: number) {
        const existing = this.effects.get(generateFvttId(`RTR${statusEffectId}`));
        if (existing) {
            // TODO: at some point need to check the duration overlap
            return;
        }

        const effect = await ActiveEffect.implementation.fromStatusEffect(statusEffectId);
        // TODO fix duration
        effect.duration = foundry.utils.mergeObject(effect.duration ?? {}, {
            rounds: roundDuration
        });
        return ActiveEffect.implementation.create(effect, { parent: this, keepId: true });
    }

    /* -------------------------------------------- */
    /*  Private Helpers                             */
    /* -------------------------------------------- */

    // TODO: use enum maybe
    _hasStatusEffect(statusEffectName?: string) {
        const existing = this.appliedEffects.find(effect => effect.name === statusEffectName);
        return existing !== undefined;
    }

    _getAttributeRollBonus(attribute?: string) {
        let foundAttribute = Object.keys(CONFIG.RTR.attributes).find(attributeName => attributeName === attribute);
        if (!foundAttribute) {
            ui.notifications?.error(`Attribute ${attribute} not found`, { console: true });
            return {};
        }
        return { rollData: `+@attributes.${foundAttribute}.value`, rollType: foundAttribute.toUpperCase() };
    }

    //TODO: use enum
    _getSkillRollBonus(skill?: string) {
        let foundSkill = Object.keys(CONFIG.RTR.skills).find(skillname => skillname === skill);
        if (!foundSkill) {
            ui.notifications?.error(`Skill ${skill} not found`, { console: true });
            return {};
        }
        if (foundSkill === 'stealth') {
            return { rollData: `+@skills.${foundSkill}.rank-@manoeuvrePenalty`, rollType: foundSkill };
        }
        return { rollData: `+@skills.${foundSkill}.rank`, rollType: foundSkill };
    }

    // TODO use, enum
    _getSaveRollBonus(save?: string) {
        switch (save) {
            case 'stability': return { rollData: '+@stabilitySave', rollType: 'STABILITY SAVE' };
            case 'dodge': return { rollData: '+@dodgeSave', rollType: 'DODGE SAVE' };
            case 'toughness': return { rollData: '+@toughnessSave', rollType: 'TOUGHNESS SAVE' };
            case 'willpower': return { rollData: '+@willpowerSave', rollType: 'WILLPOWER SAVE' };
            case 'shieldblock': return { rollData: '+@shieldBlock', rollType: 'SHIELD BLOCK' };
        }
        ui.notifications?.error(`Unkown Save ${save}`, { console: true });
        return {};
    }
s
    // TODO - use enum
    _hasResistance(type?: string) {
        const resistance = this.system.resistances.find(r => r.damageType.toUpperCase() === type.toUpperCase());
        return resistance?.value ?? 0;
    }
}

// TODO use enums
type ActorRollOptions = {
    bonus?: string,
    type?: string,
    extraDice?: string,
    attribute?: string,
    skill?: string,
    save?: string,
    advantage?: boolean,
    disadvantage?: boolean
};